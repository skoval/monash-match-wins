---
title: "Predicting match results in professional tennis"
author:
- familyname: HE
  othernames: XITONG
  address: Monash University
  email: xhee0013@student.monash.edu
  correspondingauthor: true
  qualifications: 29026342
department: Department of\newline Econometrics &\newline Business Statistics
organization: ETC5543 Internship Project
bibliography: references.bib
biblio-style: authoryear-comp
linestretch: 1.5
output:
  MonashEBSTemplates::report:
    fig_caption: yes
    fig_height: 5
    fig_width: 8
    includes:
      in_header: preamble.tex
    keep_tex: yes
    number_sections: yes
    citation_package: biblatex
    toc: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, cache=TRUE, messages=FALSE, warning=FALSE)

library(tidyverse)
library(dplyr)
library(ggplot2)
library(here)
```


```{r read-data}
atp_results<-readRDS(here("data/atp_results.rds"))
wta_results<-readRDS(here("data/wta_results.rds"))
```

# Abstract

This project examines several probabilistic models for forecasting the outcomes of professional tennis levels such as ATP or WTA matches. These models not only focus on the prediction results in the tennis matched, but also consider the head to head effect where would affect the performance in some players. In addition, the effects of surface type and the variation of player skills would be addressed in the models as one of the exploratory variables. The models are trained and evaluated on the two historical tennis matches results of approximately 38,000 tennis matches between 2010 and 2020. 

# Data description {#data}

This section mainly introduces the data, data sources and data description.   

There are two data sets used on this analysis report, and both of them are obtained from [GitHub skoval](https://github.com/skoval/monash-match-wins), which have similar data structures.  


## ATP_results

The `atp_results` data source is from [Github skoval](https://github.com/skoval/monash-match-wins). The data contains the ATP tour results in the last decay, which is a worldwide top-tier tennis tour for men organized by the Association of Tennis Professionals, with `r nrow(atp_results)` observations and `r ncol(atp_results)`variables from 2011-01-01 to 2020-01-23.   

The variables information included in the data are shown as the following table, Players, Surface,MatchID and Tier variables were mainly used for this analysis.    

```{r atp-data, warning=FALSE, message=FALSE}
atp_data <- data.frame(
  Variable = c("ID1","ID2","ID_T","ID_R","RESULT","DATE","NAME_T","DATE_T","Surface","Player1","Player2","Retired","Walkover","Qualifying","MatchID","Tier"),
  Description = c("Winner ID", "Loser ID","Terminology ID","The around in tennis match","Matches games results","Match Date","Name of the match","Date of tennis tourments","Match Surface","Match Winner","Match Loser","withdrawal of a player during a match, usually due to injury and illness","victory awarded to a player when their opponent concedes a match before it begins, usually due to injury or illness","preliminary event that offers players whose rankings don’t gain them direct entry in the main draw of a tournament, the opportunity to win a spot in that main draw","Unique ID for each match","collective term referring to the group of matches or rubbers played between two teams in a team tennis even"
  ))

atp_data %>%
  kable(caption = "Association of Tennis Professionals") %>%
  kable_styling(bootstrap_options = 
                c("striped", "condensed"), 
                full_width = F, 
                position = "center")
```


 
## WTA data

The `wta_results`data was gathered from [Github skoval](https://github.com/skoval/monash-match-wins) as well, of which is recorded the worldwide professional tennis tour match results for women. This dataset contains `r nrow(wta_results)` observation and `r ncol(wta_results)` variables from 2011-01-01 to 2020-01-23 and the data structure is shown as the below tables: 

```{r wta-data, warning=FALSE, message=FALSE}
wta_data <- data.frame(
  Variable = c("ID1","ID2","ID_T","ID_R","RESULT","DATE","NAME_T","DATE_T","Surface","Player1","Player2","Retired","Walkover","Qualifying","MatchID","Tier"),
  Description = c("Winner ID", "Loser ID","Terminology ID","The around in tennis match","Matches games results","Match Date","Name of the match","Date of tennis tourments","Match Surface","Match Winner","Match Loser","withdrawal of a player during a match, usually due to injury and illness","victory awarded to a player when their opponent concedes a match before it begins, usually due to injury or illness","preliminary event that offers players whose rankings don’t gain them direct entry in the main draw of a tournament, the opportunity to win a spot in that main draw","Unique ID for each match","collective term referring to the group of matches or rubbers played between two teams in a team tennis even"
  ))

wta_data %>%
  kable(caption = "Women’s Tennis Association Tour") %>%
  kable_styling(bootstrap_options = 
                c("striped", "condensed"), 
                full_width = F, 
                position = "center")
```


# Head to Head effect Analysis

## Evaluating the head to head effect in each tier

(explore the percentage of occurring head to head matches in different three tiers )

```{r tier_summary,fig.cap="Matches of head to head effect on each tier"}

#calculate the percentage of h2h matches in each tier for atp results

atp_results%>%
  group_by(Player1,Player2,Tier)%>%
  count()%>%
  group_by(Tier)%>%
  summarise(n=sum(n))%>%
  ungroup->atp_tier
atp_tier


atp_tier_summary<-atp_tier%>%
  mutate(total=sum(n),
         `prop`=n/total,
         per=percent(prop))

out = as.htmlwidget(formattable(atp_tier_summary,
            list(`per` = color_bar("#FA614B"))))
out$dependencies = c(out$dependencies, htmlwidgets:::widget_dependencies("sparkline", "sparkline"))
out
  
```

## Evaluating the H2H effect in each surface

(explore the percentage of occurring head to head matches in different three tiers )

```{r surface_summary,fig.cap="Matches of head to head effect on three types of surface"}

#calculate the percentage of h2h matches in each surface for atp results

atp_results%>%
  group_by(Player1,Player2,Surface)%>%
  count()%>%
  group_by(Surface)%>%
  summarise(n=sum(n))%>%
  ungroup->atp_surface


atp_surface_summary<-atp_surface%>%
  mutate(total=sum(n),
         `prop`=n/total,
         per=percent(prop))

out = as.htmlwidget(formattable(atp_surface_summary,
            list(`per` = color_bar("#FA614B"))))
out$dependencies = c(out$dependencies, htmlwidgets:::widget_dependencies("sparkline", "sparkline"))
out
```


## Calculating the head to head effect on win odds for each matches

(summarize the total matches of each pair players, and calculating the winners odd who has won most of matches between two players)


```{r long-format-matches}
# tidy up the data(rename and select variables)
atp_results%>%
  filter(Retired!="TRUE",Walkover!="TRUE")%>%
  rename(Winner_ID=ID1,Loser_ID=ID2,Winner=Player1,Loser=Player2)%>%
  select(Winner_ID,Loser_ID,Winner,Loser,Surface,Tier)->atp_matches
atp_matches$h2hid<-paste0(atp_matches$Winner_ID, 
                      ':', atp_matches$Loser_ID )
atp_matches$matches<-paste0(atp_matches$Winner, 
                      ':', atp_matches$Loser)

# Make long format by stacking winners and losers
atp_long <- rbind(
	atp_results %>% filter(Retired!="TRUE",Walkover!="TRUE")%>% dplyr::select(playerid = ID1, opponentid = ID2, ID_T, ID_R, DATE, Surface, player = Player1, MatchID, Tier) %>% dplyr::mutate(matchwin = TRUE),
	atp_results %>% filter(Retired!="TRUE",Walkover!="TRUE")%>%
	  dplyr::select(playerid = ID2, opponentid = ID1, ID_T, ID_R, DATE, Surface, player = Player2, MatchID, Tier) %>% dplyr::mutate(matchwin = FALSE)
)

head_to_head <- function(id1, id2){
	# assign h2h idea 
	ifelse(id1 > id2, paste(id1, id2, sep = ":"), paste(id2, id1, sep = ":"))
}

atp_long <- atp_long %>%
	dplyr::mutate(
		h2hid = head_to_head(playerid, opponentid)
	)
```


```{r calculating the prob}
atp_h2h_match<-atp_matches%>%
  group_by(h2hid,Winner,Loser)%>%
  tally()%>%
  ungroup(h2hid)

#use the atp_long data set to calculate the total number of each pair players where they met
atp_h2h_count<-atp_long%>%
  group_by(h2hid)%>%
  tally()%>%
  mutate(total_count=n/2)%>%
  select(-n)%>%
  ungroup()

#calculate the win probability and lose probability for each pair players in terms of total number of the matches
match_count<-left_join(atp_h2h_match,atp_h2h_count,by="h2hid")%>%
  drop_na()%>%#drop na since some of data are included in the total matches of each pair palyers but only different in winning players
  rename(p1_count=n)%>%
  mutate(p2_count=round(total_count-p1_count,3),
         prob_p1_win=round(p1_count/total_count,3),
         prob_p2_win=round(p2_count/total_count,3))
```

# Model analysis


## Pairwise Comparison Models
Pairwise comparison is the process of comparing entities in pairs to determine which one has a better chance of winning. One of the famous method for establishing pairwise comparison is Bradley Terry Model[@bradley1952rank], applying in the contest between two players.

Let $$y_{ij,t}$$ be the outcome of a tennis match that is played between player i and player j at time t. We assume that we have information about K different players over a time period of length n, i.e. i, j =1.... ,K and t =1..., n. The outcome $${y_{ij,t} =1}$$ if player i wins the match at time t whereas the outcome $${y_{ij,t} =0}$$  if player j wins the match at time t. Therefore, the outcomes about $$y_{ij,t}$$ are binary response value.

The conditional probability that yij,t =1 is given by 
$$Pij,t=P(y_{ij,t}=1|\delta_{ij,t})=\frac{exp(\delta_{ij,t})}{1+exp(\delta_{ij,t})}$$ , $$\delta_{ij,t}=\lambda_{i,j}-\lambda_{j,t}$$
where$$\lambda_{i,t}$$ represents the skill level of player i at time t and $$\lambda_{j,t}$$ represents the skill level
of player j at time t. The conditional probability of $${y_{ij,t} =0}$$ is instead equal to$$1-P_{ij,t}$$.

On the other hand, this model can be alternatively expressed in the following logit-linear way, which can be reduce the model to logistics regression on pairs of individuals:
$$logit[P(i beats j)]=logit(P(i>j))=log(\frac{P(i>j)}{1-P(i>j)})=\lambda_{i}-\lambda_{j}$$
where $$\lambda_{i}$$ =$$log\alpha_{i}$$ for all i and it can be . Based on the i.i.d(independent identifying distributed) assumption for all contests[@klaassen2001points],the parameters $$\lambda_{i}$$ can be estimated by maximum likelihood using `BradleyTerry2` package[@bradley] for generalized linear models. The `BradleyTerry2` package provides a more flexible user interface to allow a wider range of models to be fitted in the data and allows the inclusion of simple random effects, where the $$ \lambda_{i}$$ can be related to explanatory variable via a linear predictor of the form:
$$\lambda_{i}=\sum_{r=1}^{p}{\beta_{r}x_{ir}+U_{i}}$$

The inclusion of the prediction error $$U_i$$ allows for variability between players with equal covariate values and induces correlation between comparisons with a common player. 

```{r convert-factor-same-levels}
# tidy up new matches data and convert the two factors for players into same level in terms of building the model
match_count%>%
  select(Winner,Loser,p1_count,p2_count)%>%
  rename(player1=Winner,
         player2=Loser)->match

match$player1 <- factor(match$player1, levels=union(match$player1,match$player2))
match$player2 <- factor(match$player2, levels=union(match$player1, match$player2))
```


```{r simple-BT-model}
#the coefficients are maximum likelihood estimates of lambda n with lambda1( the log-ability for Tomislav Brkic) set to zero as identifying convention

#~player specifies the model for player ability, in this case it stands for ‘tennis capability’ 
model1<-BTm(cbind(win_count,lose_count),player1,player2,~player,id="player",data = match)

#summary(model1)
```


```{r p-value}
ll.null<-model1$null.deviance/-2
ll.proposed<-model1$deviance/-2
(ll.null-ll.proposed)/ll.null
1-pchisq(2*(ll.proposed-ll.null),df=(length(model1$coefficients)-1))
#The p-value is extremely small, so we can safely reject the null hypothesis that there is no head to head effect advantage.

#Since the dispersion parameter is 1, where is the variance derived from the mean, so the model is suitable as it did not underestimated

```


```{r ceof-BT-model}
#coefficient for simple BT model
Model1_Results <- data.frame(coef(model1))
Model1_Results <- data.frame("Players" = rownames(Model1_Results), "Estimate" = Model1_Results$coef.model1.)
Model1_Results$Players <- substring(as.character(Model1_Results$Players), 7)
Model1_Results$Estimate <- as.numeric(Model1_Results$Estimate)
```


```{r expected-win-prob}
player1<-match$player1
player2<-match$player2
#Calculate odds of Team1 beating Team2 is (Team1/Team2)/(Team1/Team2 + 1)
match_count$player1_Odds <- as.numeric(unlist(Model1_Results[match(player1, Model1_Results[, 1]),][2]))
#data<-cbind(player1,player1_Odds)
#data[is.na(data)]=0
match_count$player2_Odds <- as.numeric(unlist(Model1_Results[match(player2, Model1_Results[, 1]),][2]))
#data2<-cbind(player2,player2_Odds)
#data2[is.na(data2)]=0
match_count <- match_count%>%
  mutate(player1_Beat_player2_Odds=as.numeric(unlist((player1_Odds/player2_Odds)/(player1_Odds/player2_Odds + 1))),
         exp_p1_win=as.numeric(unlist(exp(player1_Odds-player2_Odds)/(1+exp(player1_Odds-player2_Odds)))),
         diff=prob_p1_win-exp_p1_win)


```

## Bayesian Paired Comparison models in Stan

**Simple Bradley Terry model: **

The `bpcs` package utilizes normal priors for the $$\lambda$$ parameters and models the outcome variable $$y_{i,j}$$ of a single contest between players i and j with a Bernoulli distribution, based on the probability of winning for $$\mathrm{P}(\left[ i \mbox{ beats } j \right]$$.

The simple Bayesian Bradley Terry Model is:

$$\mathrm{P}(\left[ i \mbox{ beats } j \right]=\frac{exp(\lambda_{i})}{exp(\lambda_{i})+exp(\lambda_{j})}=\lambda_{i}-\lambda_{j}$$

where $$y_{ij}\sim Bernoulli(p[i beats j])$$; $$ \lambda_{i} \sim N(0,\sigma_{\lambda}^2),[Prior]$$

The parameters $$ \lambda_{i}$$ can be used to rank the different players. However, in the Bayesian framework, a single measure is not obtained but rather a posterior distribution of the parameters $$ \lambda_{i}$$. By sampling from the posterior distribution of the log-abilities of the players, it is possible to create a posterior distribution of the ranks of the players, which helps to evaluate the uncertainty in the ranking system.

**Davidson Model: **

Ties refer to the case where a subject does not express a preference for a player in a contest. Therefore, **Davidson model** would be introduced to handle ties in the contest between two players, which adds an additional parameter$$\upsilon$$ and computes two probabilities: the probability of i beating j given that it was not a tie $$ P[i beats j|not tie] $$and the probability of the result being a tie $$P[i ties j]$$. A Bayesian formulation of the model is represented below:

$$\mathrm{P}(\left[ i \mbox{ beats } j \right]
|  \mbox{ not tie })=\frac{exp(\lambda_{i})}{exp(\lambda_{i})+exp(\lambda_{j})+exp(\upsilon+\frac{\lambda_{i}+\lambda_{j}}{2})}$$;
$$\mathrm{Pr}\left[ i \mbox{ beats } j \right]
=\frac{exp(\upsilon+\frac{\lambda_{i}+\lambda_{j}}{2})}{exp(\lambda_{i})+exp(\lambda_{j})+exp(\upsilon+\frac{\lambda_{i}+\lambda_{j}}{2})}$$;
$$y_{ij}\sim Bernoulli(\mathrm{P}\left[ i \mbox{ beats } j \right]| \mbox{ not tie })$$;
$$tie_{i,j} \sim Bernoulli(\mathrm{P}\left[ i \mbox{ ties } j \right])$$;
$$ \lambda_{i} \sim N(0,\sigma_{\lambda}^2),[Prior]$$;
$$\upsilon \sim N(0,\sigma_{\lambda}^2),[Prior]$$

where the choice of prior in $$\upsilon$$ parameter refers to the prior belief on how ties are affected by the relative difference in players’ abilities.

```{r construct-bpc_data}
atp_surface<-atp_matches%>%
  group_by(h2hid,Winner,Loser,Surface)%>%
  tally()%>%
  ungroup()%>%
  pivot_wider(names_from = Surface,
              values_from=n,
              values_fill=0)
atp_long%>%
  group_by(h2hid,Surface)%>%
  tally()%>%
  mutate(total_count=n/2)%>%
  select(-n)%>%
  ungroup()%>%
   pivot_wider(names_from = Surface,
              values_from=total_count,
              values_fill=0)->h2h_surface_atp

atp_surface%>%
  rename(p1_clay=Clay,
         p1_grass=Grass,
         p1_hard=Hard)%>%
  left_join(h2h_surface_atp,by="h2hid")%>%
  mutate(p2_clay=Clay-p1_clay,
         p2_grass=Grass-p1_grass,
         p2_hard=Hard-p1_hard,
         p1_clay=as.numeric(p1_clay),
         p1_grass=as.numeric(p1_grass),
         p1_hard=as.numeric(p1_hard))%>%
  drop_na()%>%
  select(-Clay,-Grass,-Hard)->surface

surface%>%
  rename(player1=Winner,player2=Loser)%>%
  select(player1,player2,p1_clay,p2_clay)%>%
  mutate(Type=paste("Clay"))%>%
  rename(p1_count=p1_clay,
         p2_count=p2_clay)->clay

surface%>%
  rename(player1=Winner,player2=Loser)%>%
  select(player1,player2,p1_grass,p2_grass)%>%
  mutate(Type=paste("Grass"))%>%
  rename(p1_count=p1_grass,
         p2_count=p2_grass)->grass

surface%>%
  rename(player1=Winner,player2=Loser)%>%
  select(player1,player2,p1_hard,p2_hard)%>%
  mutate(Type=paste("Hard"))%>%
  rename(p1_count=p1_hard,
         p2_count=p2_hard)->hard

clay%>%
  rbind(hard)%>%
  rbind(grass)->bpcs_data
bpcs_data%>%
   arrange(desc(p1_count))%>%
  head(1000)%>%
  na.omit()%>%
  mutate(player1=as.character(player1),
         player2=as.character(player2))->bpcs_sample
```


```{r bpc-BT-model}
library(bpcs)
library(cmdstanr)
mod1 <- bpc(data = bpcs_sample,
          player0 = 'player1',
          player1 = 'player2',
         player0_score = "p1_count",
         player1_score = "p2_count",
          model_type = 'bt',
         solve_ties = 'random',
           priors = list(prior_lambda_std = 2.0),
            iter = 3000)
mod2 <- bpc(data = bpcs_sample,
          player0 = 'player1',
          player1 = 'player2',
         player0_score = "p1_count",
         player1_score = "p2_count",
          model_type = 'davidson',
          solve_ties = 'none', #there are no ties
          priors = list(prior_lambda_std = 2.0),
            iter = 3000)
```

